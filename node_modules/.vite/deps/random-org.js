var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/random-org/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/random-org/src/rpc.js"(exports, module) {
    var https = require_https();
    var makeRpcRequest = function(options) {
      return new Promise(function(resolve, reject) {
        var postData = JSON.stringify({
          jsonrpc: "2.0",
          method: options.method,
          params: options.params,
          id: options.id || 1
        });
        var endpoint = options.endpoint;
        var requestParams = {
          protocol: endpoint.protocol,
          hostname: endpoint.hostname,
          port: endpoint.port || 443,
          path: endpoint.path,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": Buffer.byteLength(postData, "utf8")
          }
        };
        var req = https.request(requestParams, function(res) {
          res.setEncoding("utf8");
          var responseBody = "";
          res.on("data", function(chunk) {
            responseBody += chunk;
          });
          res.on("end", function() {
            try {
              responseBody = JSON.parse(responseBody);
              resolve(responseBody);
            } catch (e) {
              reject(new Error("Received invalid JSON"));
            }
          });
        });
        req.on("error", reject);
        req.write(postData);
        req.end();
      });
    };
    module.exports.makeRpcRequest = makeRpcRequest;
  }
});

// node_modules/random-org/src/RandomOrg.js
var require_RandomOrg = __commonJS({
  "node_modules/random-org/src/RandomOrg.js"(exports, module) {
    var url = require_url();
    var makeRpcRequest = require_rpc().makeRpcRequest;
    function RandomOrg(opts) {
      this.apiKey = opts.apiKey;
      if (typeof this.apiKey !== "string") {
        throw new Error("options.apiKey is required & must be a String");
      }
      this.endpoint = opts.endpoint || "https://api.random.org/json-rpc/2/invoke";
      this.endpoint = url.parse(this.endpoint);
      this._makeRpcRequest = makeRpcRequest;
    }
    [
      "generateIntegers",
      "generateIntegerSequences",
      "generateDecimalFractions",
      "generateGaussians",
      "generateStrings",
      "generateUUIDs",
      "generateBlobs",
      "getUsage",
      "generateSignedIntegers",
      "generateSignedIntegerSequences",
      "generateSignedDecimalFractions",
      "generateSignedGaussians",
      "generateSignedStrings",
      "generateSignedUUIDs",
      "generateSignedBlobs",
      "verifySignature",
      "getResult"
    ].forEach(function(methodName) {
      RandomOrg.prototype[methodName] = createInvocation(methodName);
    });
    RandomOrg.prototype._enrichParams = function(method, params) {
      if (method === "verifySignature") {
        return params;
      }
      var requestParams = { apiKey: this.apiKey };
      Object.keys(params || {}).forEach(function(property) {
        requestParams[property] = params[property];
      });
      return requestParams;
    };
    function createInvocation(methodName) {
      return function(params) {
        var requestOpts = {
          endpoint: this.endpoint,
          method: methodName,
          params: this._enrichParams(methodName, params)
        };
        return this._makeRpcRequest(requestOpts).then(function(response) {
          if (response.error) {
            var error = new Error(response.error.message);
            error.code = response.error.code;
            throw error;
          } else {
            return response.result;
          }
        });
      };
    }
    module.exports = RandomOrg;
  }
});

// node_modules/random-org/index.js
var require_random_org = __commonJS({
  "node_modules/random-org/index.js"(exports, module) {
    module.exports = require_RandomOrg();
  }
});
export default require_random_org();
//# sourceMappingURL=random-org.js.map
